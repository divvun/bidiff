#[global_allocator]
static GLOBAL: mimalloc::MiMalloc = mimalloc::MiMalloc;

mod ring_pipe;

use anyhow::{Context, Result};
use bidiff::DiffParams;
use clap::Parser;
use memmap2::Mmap;
use ring_pipe::ring_pipe;
use size::Size;
use std::{
    fs::File,
    io::{self, BufReader, BufWriter, Write},
    path::PathBuf,
    time::Instant,
};
use tracing::info;

/// Generate and apply binary patches
#[derive(Parser, Debug)]
struct Cli {
    #[command(subcommand)]
    cmd: Command,
}

#[derive(clap::Subcommand, Debug)]
enum Command {
    /// Write the diff of two files to a patch file
    Diff(Diff),
    /// Apply a patch file generated by this tool
    Patch(Patch),
    /// Round-trip verification (diff then patch)
    Cycle(Cycle),
}

#[derive(Parser, Debug)]
struct Diff {
    older: PathBuf,
    newer: PathBuf,
    patch: PathBuf,
    /// Hash index block size (minimum 4)
    #[arg(long, default_value_t = 32)]
    block_size: usize,
    /// Optionally specify a chunk size
    #[arg(long)]
    scan_chunk_size: Option<usize>,
    /// Max threads for parallel scanning (default: all cores)
    #[arg(long)]
    threads: Option<usize>,
    /// Maximize compression (zstd level 22); slower but ~30% smaller patches
    #[arg(long)]
    max: bool,
}

#[derive(Parser, Debug)]
struct Patch {
    older: PathBuf,
    patch: PathBuf,
    output: PathBuf,
}

#[derive(Parser, Debug)]
struct Cycle {
    older: PathBuf,
    newer: PathBuf,
    /// Hash index block size (minimum 4)
    #[arg(long, default_value_t = 32)]
    block_size: usize,
    /// Optionally specify a chunk size
    #[arg(long)]
    scan_chunk_size: Option<usize>,
    /// Max threads for parallel scanning (default: all cores)
    #[arg(long)]
    threads: Option<usize>,
    /// Maximize compression (zstd level 22); slower but ~30% smaller patches
    #[arg(long)]
    max: bool,
}

fn main() -> Result<()> {
    tracing_subscriber::fmt::init();

    let Cli { cmd } = Cli::parse();
    match cmd {
        Command::Diff(args) => {
            do_diff(&args)?;
        }
        Command::Patch(args) => {
            do_patch(&args)?;
        }
        Command::Cycle(args) => {
            do_cycle(&args)?;
        }
    }

    Ok(())
}

fn do_cycle(
    Cycle {
        older,
        newer,
        block_size,
        scan_chunk_size,
        threads,
        max,
    }: &Cycle,
) -> Result<()> {
    info!("Memory-mapping older and newer...");
    let (older, newer) = (mmap_file(older)?, mmap_file(newer)?);

    info!(
        "Before {}, After {}",
        Size::from_bytes(older.len()),
        Size::from_bytes(newer.len()),
    );

    let mut compatch = Vec::new();
    let before_diff = Instant::now();

    {
        let mut compatch_w = io::Cursor::new(&mut compatch);

        let (mut patch_r, mut patch_w) = ring_pipe(1024 * 1024);
        let diff_params =
            DiffParams::with_threads(*block_size, *scan_chunk_size, *threads).unwrap();
        std::thread::scope(|s| {
            s.spawn(|| {
                bidiff::simple_diff_with_params(&older[..], &newer[..], &mut patch_w, &diff_params)
                    .context("simple diff with params")
                    .unwrap();
                patch_w.flush().unwrap();
                drop(patch_w);
            });
            let zstd_level = if *max { 22 } else { 3 };
            zstd::stream::copy_encode(&mut patch_r, &mut compatch_w, zstd_level)
                .context("compress")
                .unwrap();
        });
    }

    let diff_duration = before_diff.elapsed();

    let ratio = (compatch.len() as f64) / (newer.len() as f64);

    let mut fresh = Vec::with_capacity(newer.len());
    let before_patch = Instant::now();
    {
        let mut older = io::Cursor::new(&older[..]);

        let (patch_r, patch_w) = ring_pipe(1024 * 1024);

        std::thread::scope(|s| {
            s.spawn(|| {
                zstd::stream::copy_decode(&compatch[..], patch_w)
                    .context("decompress")
                    .unwrap();
            });

            let mut r = bipatch::Reader::new(patch_r, &mut older)
                .context("read patch")
                .unwrap();
            let fresh_size = io::copy(&mut r, &mut fresh).unwrap();

            assert_eq!(fresh_size as usize, newer.len());
        });
    }
    let patch_duration = before_patch.elapsed();

    let newer_hash = blake3::hash(&newer[..]);
    let fresh_hash = blake3::hash(&fresh[..]);

    anyhow::ensure!(newer_hash == fresh_hash, "Hash mismatch!");

    let cp = format!("patch {}", Size::from_bytes(compatch.len()));
    let cr = format!(
        "{:03.3}% of {}",
        ratio * 100.0,
        Size::from_bytes(newer.len())
    );
    let cdd = format!("dtime {:?}", diff_duration);
    let cpd = format!("ptime {:?}", patch_duration);
    println!("{:12} {:20} {:27} {:20} {:20}", "zstd", cp, cr, cdd, cpd);

    Ok(())
}

fn do_patch(
    Patch {
        older,
        patch,
        output,
    }: &Patch,
) -> Result<()> {
    let start = Instant::now();

    let compatch_r = BufReader::new(File::open(patch).context("open patch file")?);
    let (patch_r, patch_w) = ring_pipe(1024 * 1024);

    std::thread::spawn(move || {
        zstd::stream::copy_decode(compatch_r, patch_w)
            .context("decompress")
            .unwrap();
    });

    let older = mmap_file(older)?;
    let mut older_cursor = io::Cursor::new(&older[..]);
    let mut fresh_r = bipatch::Reader::new(patch_r, &mut older_cursor).context("read patch")?;
    let mut output_w = BufWriter::new(File::create(output).context("create patch file")?);
    io::copy(&mut fresh_r, &mut output_w).context("write output file")?;

    info!("Completed in {:?}", start.elapsed());

    Ok(())
}

fn mmap_file(path: &PathBuf) -> Result<Mmap> {
    let file = File::open(path).with_context(|| format!("open {}", path.display()))?;
    let mmap = unsafe { memmap2::MmapOptions::new().populate().map(&file) }
        .with_context(|| format!("mmap {}", path.display()))?;
    #[cfg(unix)]
    mmap.advise(memmap2::Advice::HugePage).ok();
    Ok(mmap)
}

fn do_diff(
    Diff {
        older,
        newer,
        patch,
        block_size,
        scan_chunk_size,
        threads,
        max,
    }: &Diff,
) -> Result<()> {
    let start = Instant::now();

    let older_contents = mmap_file(older)?;
    let newer_contents = mmap_file(newer)?;

    let (mut patch_r, mut patch_w) = ring_pipe(1024 * 1024);
    let diff_params = DiffParams::with_threads(*block_size, *scan_chunk_size, *threads).unwrap();
    std::thread::scope(|s| {
        s.spawn(|| {
            bidiff::simple_diff_with_params(
                &older_contents[..],
                &newer_contents[..],
                &mut patch_w,
                &diff_params,
            )
            .context("simple diff with params")
            .unwrap();
            patch_w.flush().unwrap();
            drop(patch_w);
        });

        let mut compatch_w =
            BufWriter::new(File::create(patch).context("create patch file").unwrap());
        let zstd_level = if *max { 22 } else { 3 };
        zstd::stream::copy_encode(&mut patch_r, &mut compatch_w, zstd_level)
            .context("write output file")
            .unwrap();
        compatch_w
            .flush()
            .context("finish writing output file")
            .unwrap();
    });

    info!("Completed in {:?}", start.elapsed());

    Ok(())
}
